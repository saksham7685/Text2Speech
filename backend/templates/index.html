<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text to Speech with Multi language support</title>
    <link rel="stylesheet" href="style.css">

</head>
<body>
    <h1>Text to Speech with Multi language support</h1>
    
    <form>
        <label for="voice">Select Voice: </label>
        <select id="voiceSelect" class="voice-select"></select><br><br>

        <label for="text">Enter text to speak: </label>
        <textarea class="txt" rows="2" cols="50"></textarea><br><br>

        <label for="pitch">Pitch: </label>
        <input type="range" id="pitch" min="0" max="2" step="0.01" value="1">
        <span class="pitch-value">1</span><br><br>

        <label for="rate">Rate: </label>
        <input type="range" id="rate" min="0.5" max="2" step="0.01" value="1">
        <span class="rate-value">1</span><br><br>

        <!-- Optional: let NN suggest params and detect language -->
        <button type="button" id="nnSuggestBtn">Suggest from NN</button>
        <span id="nnParamStatus" style="margin-left:8px;color:#555;"></span>
        <br>
        <small id="langStatus" style="color:#555;"></small>
        <br><br>

        <button type="submit">Speak</button>
    </form>

    <script>
        const synth = window.speechSynthesis;

        const inputForm = document.querySelector("form");
        const inputTxt = document.querySelector(".txt");
        const voiceSelect = document.querySelector("select");
        const pitch = document.querySelector("#pitch");
        const pitchValue = document.querySelector(".pitch-value");
        const rate = document.querySelector("#rate");
        const rateValue = document.querySelector(".rate-value");
        const nnSuggestBtn = document.getElementById("nnSuggestBtn");
        const nnParamStatus = document.getElementById("nnParamStatus");
        const langStatus = document.getElementById("langStatus");

        let voices = [];

        function populateVoiceList() {
            voices = synth.getVoices();

            for (let i = 0; i < voices.length; i++) {
                const option = document.createElement("option");
                option.textContent = `${voices[i].name} (${voices[i].lang})` ;

                if (voices[i].default) {
                    option.textContent += " â€” DEFAULT";
                }

                option.setAttribute("data-lang", voices[i].lang);
                option.setAttribute("data-name", voices[i].name);
                voiceSelect.appendChild(option);
            }
        }

        populateVoiceList();
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = populateVoiceList;
        }

        // Initialize labels on first load
        pitchValue.textContent = pitch.value;
        rateValue.textContent = rate.value;

        // Keep slider value labels in sync with live changes
        pitch.addEventListener('input', () => { pitchValue.textContent = pitch.value; });
        rate.addEventListener('input', () => { rateValue.textContent = rate.value; });

        // NN Suggest (optional): fetch suggested pitch/rate and detected language
        nnSuggestBtn?.addEventListener('click', async () => {
            const text = inputTxt.value || "";
            nnParamStatus.textContent = "";
            langStatus.textContent = "";
            try {
                const [prRes, langRes] = await Promise.all([
                    fetch('/nn_params', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text }) }),
                    fetch('/nn_language', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text }) })
                ]);
                const pr = await prRes.json();
                const lg = await langRes.json();
                // Apply pitch/rate to sliders (does not auto-speak)
                pitch.value = pr.pitch;
                pitchValue.textContent = pr.pitch;
                rate.value = pr.rate;
                rateValue.textContent = pr.rate;
                nnParamStatus.textContent = `Pitch=${pr.pitch}, Rate=${pr.rate}`;
                langStatus.textContent = `Language: ${lg.language} (scores: ${Object.entries(lg.scores).map(([k,v])=>`${k}:${v}`).join(', ')})`;
            } catch (e) {
                nnParamStatus.textContent = 'NN suggest failed';
            }
        });

        inputForm.onsubmit = async (event) => {
            event.preventDefault();

            const text = (inputTxt.value || "").trim();
            if (!text) {
                console.warn('No text to speak.');
                return;
            }

            // If voices not loaded yet, wait briefly for onvoiceschanged
            if (!voices || voices.length === 0) {
                await new Promise((resolve) => setTimeout(resolve, 200));
                if ((!voices || voices.length === 0) && speechSynthesis.onvoiceschanged) {
                    await new Promise((resolve) => {
                        const prev = speechSynthesis.onvoiceschanged;
                        speechSynthesis.onvoiceschanged = () => {
                            populateVoiceList();
                            prev && prev();
                            resolve();
                        };
                    });
                }
            }

            try {
                // Cancel any ongoing or queued speech to avoid silence
                if (synth.speaking || synth.paused) {
                    synth.cancel();
                }

                const utterThis = new SpeechSynthesisUtterance(text);

                // Choose voice: selected option if present, else default voice
                let chosen = null;
                const sel = voiceSelect.selectedOptions && voiceSelect.selectedOptions[0];
                const selectedName = sel && sel.getAttribute("data-name");
                if (selectedName && voices && voices.length) {
                    chosen = voices.find(v => v.name === selectedName) || null;
                }
                if (!chosen && voices && voices.length) {
                    chosen = voices.find(v => v.default) || voices[0];
                }
                if (chosen) utterThis.voice = chosen;

                // Ensure numeric pitch/rate
                utterThis.pitch = parseFloat(pitch.value) || 1.0;
                utterThis.rate = parseFloat(rate.value) || 1.0;

                // Basic logging hooks
                utterThis.onstart = () => console.log('Speech start', { voice: chosen?.name, pitch: utterThis.pitch, rate: utterThis.rate });
                utterThis.onend = () => console.log('Speech end');
                utterThis.onerror = (e) => console.error('Speech error', e);

                synth.speak(utterThis);
                inputTxt.blur();
            } catch (err) {
                console.error('Failed to speak:', err);
            }
        };

        // Add Pause functionality
        pauseBtn.addEventListener('click', () => {
            if (synth.speaking && !synth.paused) {
                synth.pause();
            }
        });

        // Add Resume functionality
        resumeBtn.addEventListener('click', () => {
            if (synth.paused) {
                synth.resume();
            }
        });
    </script>
</body>
</html>
